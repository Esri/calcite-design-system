import fs from "fs";
import postcss from "postcss";
import scss from "postcss-scss";
import dedent from "dedent";
import { globby } from "globby";

const propPrefix = "--calcite-internal-";
const autoGeneratedTag = "// AUTO-GENERATED â€” do not modify. Changes will be overwritten.";
const noticeHeader = dedent`
  ${autoGeneratedTag}
  //
  // Internal CSS custom properties for component use only. Overwriting is not recommended.
  //\n
  `;
const noticeRegex = new RegExp(`^${autoGeneratedTag}[\\s\\S]*?(?:\\n\\s*\\n)`, "m");

function collectCustomProps(root: postcss.Root, prefix: string): string[] {
  const props = new Set<string>();
  root.walkDecls((decl) => {
    if (decl.prop.startsWith(prefix)) {
      props.add(decl.prop);
    }
  });
  return [...props].sort();
}

function removeExistingNotice(content: string): string {
  return content.replace(noticeRegex, "");
}

function buildNoticeBlock(props: string[]): string {
  if (props.length === 0) {
    return "";
  }

  return dedent`${noticeHeader + props.map((prop) => `// ${prop}`).join("\n")}\n`;
}

/**
 * Ensures internal doc is added after public doc
 *
 * @param content
 * @param noticeBlock
 */
function insertNoticeAfterLeadingComments(content: string, noticeBlock: string): string {
  const lines = content.split("\n");
  let insertIndex = 0;
  let inBlockComment = false;

  while (insertIndex < lines.length) {
    const line = lines[insertIndex].trim();

    if (inBlockComment) {
      if (line.includes("*/")) {
        inBlockComment = false;
      }
      insertIndex++;
      continue;
    }

    if (line.startsWith("/*")) {
      inBlockComment = true;
      insertIndex++;
      continue;
    }

    if (line.startsWith("//") || line === "") {
      insertIndex++;
      continue;
    }

    break;
  }

  const before = lines.slice(0, insertIndex);
  const after = lines.slice(insertIndex);

  const updatedBefore = [...before, noticeBlock.trimEnd()];
  // Only add a blank line if the next line isn't already blank
  if (after[0] && after[0].trim() !== "") {
    updatedBefore.push("");
  }

  return [...updatedBefore, ...after].join("\n");
}

async function processFile(filePath: string) {
  const source = fs.readFileSync(filePath, "utf8");
  const root = postcss().process(source, { from: filePath, syntax: scss }).root;
  const props = collectCustomProps(root, propPrefix);
  const cleaned = removeExistingNotice(source);

  if (props.length === 0) {
    if (cleaned !== source) {
      fs.writeFileSync(filePath, cleaned);
    }
    return;
  }

  const noticeBlock = buildNoticeBlock(props);
  const updated = insertNoticeAfterLeadingComments(cleaned, noticeBlock);
  if (updated !== source) {
    fs.writeFileSync(filePath, updated);
  }
}

async function main() {
  console.log("Updating custom prop documentation...");

  const files = await globby(["src/components/**/*.scss"]);

  if (files.length === 0) {
    console.log("No SCSS files found.");
    return;
  }

  for (const file of files) {
    await processFile(file);
  }

  console.log("Custom prop documentation updated successfully.");
}

try {
  await main();
} catch (error) {
  console.error("Error processing files:", error);
  process.exit(1);
}
