import fs from "fs";
import postcss, { Root } from "postcss";
import scss from "postcss-scss";
import dedent from "dedent";
import { globby } from "globby";

const internalPropPrefix = "--calcite-internal-";
const autoGeneratedTag = "// AUTO-GENERATED â€” do not modify. Changes will be overwritten.";
const noticeHeader = dedent`
  ${autoGeneratedTag}
  //
  // Internal CSS custom properties for component use only. Overwriting is not recommended.
  //
`;

const noticeBlockRegex = new RegExp(`^${autoGeneratedTag}[\\s\\S]*?(?:\\n\\s*\\n)`, "m");

function extractInternalProps(root: Root, prefix: string): string[] {
  const internalProps = new Set<string>();
  root.walkDecls((decl) => {
    if (decl.prop.startsWith(prefix)) {
      internalProps.add(decl.prop);
    }
  });
  return Array.from(internalProps).sort();
}

function stripExistingNoticeBlock(content: string): string {
  return content.replace(noticeBlockRegex, "");
}

function createNoticeBlock(props: string[]): string {
  return !props.length ? "" : dedent`${noticeHeader}\n${props.map((prop) => `// ${prop}`).join("\n")}\n`;
}

/**
 * Inserts the notice block after any leading comments.
 *
 * @param content
 * @param noticeBlock
 */
function insertNoticeAfterComments(content: string, noticeBlock: string): string {
  const lines = content.split("\n");
  let insertAt = 0;
  let insideBlockComment = false;

  while (insertAt < lines.length) {
    const line = lines[insertAt].trim();

    if (insideBlockComment) {
      if (line.includes("*/")) {
        insideBlockComment = false;
      }
      insertAt++;
      continue;
    }

    if (line.startsWith("/*")) {
      insideBlockComment = true;
      insertAt++;
      continue;
    }

    if (line.startsWith("//") || line === "") {
      insertAt++;
      continue;
    }

    break;
  }

  const before = lines.slice(0, insertAt);
  const after = lines.slice(insertAt);

  const updatedBefore = [...before, noticeBlock.trimEnd()];
  if (after[0] && after[0].trim() !== "") {
    updatedBefore.push("");
  }

  return [...updatedBefore, ...after].join("\n");
}

async function updateFileWithInternalProps(filePath: string): Promise<void> {
  const source = fs.readFileSync(filePath, "utf8");
  const root = postcss().process(source, { from: filePath, syntax: scss }).root;
  const internalProps = extractInternalProps(root, internalPropPrefix);
  const contentWithoutNotice = stripExistingNoticeBlock(source);

  if (!internalProps.length) {
    if (contentWithoutNotice !== source) {
      fs.writeFileSync(filePath, contentWithoutNotice);
    }
    return;
  }

  const noticeBlock = createNoticeBlock(internalProps);
  const updatedContent = insertNoticeAfterComments(contentWithoutNotice, noticeBlock);

  if (updatedContent !== source) {
    fs.writeFileSync(filePath, updatedContent);
  }
}

async function main(): Promise<void> {
  console.log("Updating internal custom property documentation...");

  const scssFiles = await globby(["src/components/**/*.scss"]);

  if (!scssFiles.length) {
    console.log("No SCSS files found.");
    return;
  }

  for (const filePath of scssFiles) {
    await updateFileWithInternalProps(filePath);
  }

  console.log("Internal custom property documentation updated.");
}

try {
  await main();
} catch (error) {
  console.error("Error updating internal custom property documentation:", error);
  process.exit(1);
}
